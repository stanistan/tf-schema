package main

import (
	"text/template"
)

var packageTemplate = template.Must(template.New("").Parse(`// Code Generated by {{.Self}} DO NOT EDIT.
//
// Params: [ {{.Args}} ]

package {{.Package}}

import (
	"fmt"

	"github.com/pkg/errors"

	schema "{{.Self}}"
	tfschema "github.com/hashicorp/terraform-plugin-sdk/helper/schema"

	{{if .ImportedPackage }}
	{{.ImportedPackage.Name}} "{{.ImportedPackage.Source}}"
	{{end}}
)

{{range .TypeDefs}}
// {{.Name $.NS}} is a typed version of {{.TFName}} scoped directly to {{$.Client}} instead of interface{}.
type {{.Name $.NS}} {{.Signature $.Client}}
{{end}}

// {{.NS}}Resource is a typed version of a tfschema.Resource.
//
// Convert this to a standard terraform resource with r.AsResource().
type {{.NS}}Resource struct {
	{{.TypeDefs.Create.DeclareName  $.NS}}
	{{.TypeDefs.Read.DeclareName    $.NS}}
	{{.TypeDefs.Update.DeclareName  $.NS}}
	{{.TypeDefs.Delete.DeclareName  $.NS}}
	{{.TypeDefs.Exists.DeclareName  $.NS}}

	Schema *schema.Schema
}

// AsResource converts this to a tfschema.Resource
func (r *{{.NS}}Resource) AsResource() *tfschema.Resource {
	return &tfschema.Resource{
		{{.TypeDefs.Create.FieldAssignWrapFn $.NS}},
		{{.TypeDefs.Read.FieldAssignWrapFn $.NS}},
		{{.TypeDefs.Update.FieldAssignWrapFn $.NS}},
		{{.TypeDefs.Delete.FieldAssignWrapFn $.NS}},
		{{.TypeDefs.Exists.FieldAssignWrapFn $.NS}},
		Schema: r.Schema.Get(),
	}
}

// {{.NS}}Provider is a typed version of tfschema.Provider.
type {{.NS}}Provider struct {
	Schema 			*schema.Schema
	ResourcesMap 	map[string]schema.ResourceConverible
	DataSourcesMap 	map[string]schema.ResourceConverible

	ConfigureFunc 	{{.TypeDefs.Configure.Name $.NS}}
}

// AsProvider converts this to a tfschema.Provider
func (p *{{.NS}}Provider) AsProvider() *tfschema.Provider {
	var configure tfschema.ConfigureFunc
	if p.ConfigureFunc != nil {
		configure = func(d *tfschema.ResourceData) (interface{}, error) {
			return p.ConfigureFunc(d)
		}
	}

	return &tfschema.Provider{
		Schema:         p.Schema.Get(),
		ResourcesMap:   schema.ConvertResourceMap(p.ResourcesMap),
		DataSourcesMap: schema.ConvertResourceMap(p.DataSourcesMap),
		ConfigureFunc:  configure,
	}
}

func {{.Signatures.singleReturn.WrapFn .NS}} (name string, exec func(*tfschema.ResourceData, *{{.Client}}) error) func(*tfschema.ResourceData, interface{}) error {
	if exec == nil {
		return nil
	}

	return func(d *tfschema.ResourceData, meta interface{}) error {
		c, ok := meta.(*{{.Client}})
		if !ok {
			return fmt.Errorf("meta misconfigured -- expected {{.Client}}, cannot execute %s", name)
		}
		return errors.WithStack(exec(d, c))
	}
}

func {{.Signatures.boolReturn.WrapFn .NS}} (name string, exec func(*tfschema.ResourceData, *{{.Client}}) (bool, error)) func(*tfschema.ResourceData, interface{}) (bool, error) {
	if exec == nil {
		return nil
	}

	return func(d *tfschema.ResourceData, meta interface{}) (bool, error) {
		c, ok := meta.(*{{.Client}})
		if !ok {
			return false, fmt.Errorf("meta misconfigured -- expected {{.Client}}, cannot execute %s", name)
		}
		exists, err := exec(d, c)
		return exists, errors.WithStack(err)
	}
}
`))
